{"version":3,"file":"AudioPlayer-db2e617a.js","sources":["../../../src/components/AudioPlayer/AudioPlayer.tsx"],"sourcesContent":["import { Box, chakra, useMultiStyleConfig } from \"@chakra-ui/react\";\nimport React, { useState, forwardRef, useEffect } from \"react\";\n\nimport ComponentWrapper from \"../ComponentWrapper/ComponentWrapper\";\n\n/*\n * List all the third-party services to be used for basic type checks\n * and to define AudioType.\n */\nconst thirdPartyServices = [\"libsyn\", \"soundcloud\", \"spotify\"] as const;\nexport type ThirdPartyAudioType = typeof thirdPartyServices[number];\nexport type AudioType = ThirdPartyAudioType | \"file\";\n\nexport interface AudioPlayerProps {\n  /** Required string used to specify the type of audio playback. */\n  audioType: AudioType;\n  /** Optional className you can add in addition to `audio-player`. */\n  className?: string;\n  /** Optional string to set the text for the audio player description. */\n  descriptionText?: string;\n  /** Optional string to set a code snippet provided by Libsyn, SoundCloud or Spotify; the\n   * `AudioPlayer` component will accept the `embedCode` prop or the `filePath` prop.\n   */\n  embedCode?: string;\n  /** Optional string to set the audio file, the path can be relative or absolute\n   * referring to a locally hosted file, or a fully qualified URL pointing to a locally hosted file\n   * or to another domain altogether.\n   * TODO: This prop won't be used until a future version.\n   */\n  /*  filePath?: string; */\n  /** Optional string value used to set the text for a `Heading` component, or\n   * a DS Heading component that can be passed in.\n   */\n  headingText?: string | JSX.Element;\n  /** Optional string to set the text for a `HelperErrorText` component. */\n  helperText?: string;\n  /** ID that other components can cross reference for accessibility purposes. */\n  id?: string;\n  /** Optional title to added to the `<iframe>` element for improved accessibility. If omitted, a\n   * generic title will be added.\n   */\n  iframeTitle?: string;\n}\n\n/**\n * Renders an audio player from 3rd party services such as Libsyn, SoundCloud, and Spotify.\n */\nexport const AudioPlayer = chakra(\n  forwardRef<HTMLDivElement, React.PropsWithChildren<AudioPlayerProps>>(\n    (props, ref?) => {\n      const {\n        audioType,\n        className,\n        descriptionText,\n        embedCode,\n        headingText,\n        helperText,\n        id,\n        iframeTitle = null,\n        ...rest\n      } = props;\n\n      const [invalidEmbed, setInvalidEmbed] = useState<boolean>(false);\n      const [iframeDoc, setIframeDoc] = useState<HTMLIFrameElement | undefined>(\n        undefined\n      );\n\n      /**\n       * Main hooks to check the embedCode structure.\n       */\n      useEffect(() => {\n        // The root iframe object generated from the embedCode.\n        const iframe = parseIframeEmbedCode(embedCode);\n\n        // when no embedCode or it was a broken code.\n        let isInvalidEmbed =\n          !embedCode || !iframe || !isValidEmbedCode(audioType, iframe);\n\n        // Only set the iframe title if it doesn't already have it in the iframe.\n        if (iframe && !iframe.title) {\n          iframe.title = iframeTitle ? iframeTitle : \"Embedded audio player\";\n        }\n\n        const isThirdPartyService: boolean = !!thirdPartyServices.find(\n          (service) => service === audioType\n        );\n        const isThirdPartyWithoutCode = isThirdPartyService && !embedCode;\n        if (isThirdPartyWithoutCode) {\n          console.warn(\n            \"NYPL Reservoir AudioPlayer: The `embedCode` prop is required when using a 3rd party streaming service.\"\n          );\n          isInvalidEmbed = true;\n        }\n\n        setInvalidEmbed(isInvalidEmbed);\n        setIframeDoc(iframe);\n      }, [embedCode, audioType, iframeTitle]);\n\n      const errorMessage =\n        \"<strong>Error: </strong>This audio player has not been configured properly. Please contact the site administrator.\";\n\n      function isValidEmbedCode(\n        audioType: AudioType,\n        doc: HTMLIFrameElement\n      ): boolean {\n        return audioType !== \"file\" && doc?.src?.includes(`${audioType}.com`);\n      }\n\n      const styles = useMultiStyleConfig(\"AudioPlayer\", {});\n\n      /**\n       * Builder function to build the finalized render element, we prioritize localfile over 3rd party code\n       * but for the current version, we only use 3rd party code.\n       */\n      function buildFinalElement(): JSX.Element {\n        return iframeDoc ? (\n          <Box\n            dangerouslySetInnerHTML={{\n              __html: iframeDoc.outerHTML,\n            }}\n          />\n        ) : null;\n      }\n\n      const embedElement = buildFinalElement();\n\n      return (\n        <ComponentWrapper\n          className={`audioplayer ${className}`}\n          headingText={headingText}\n          descriptionText={descriptionText}\n          helperText={helperText}\n          id={`${id}-componentWrapper`}\n          data-testid=\"audio-player-component\"\n          ref={ref}\n          __css={styles}\n          {...rest}\n        >\n          {invalidEmbed ? (\n            <Box\n              dangerouslySetInnerHTML={{ __html: errorMessage }}\n              __css={styles.invalid}\n            />\n          ) : (\n            <>{embedElement}</>\n          )}\n        </ComponentWrapper>\n      );\n    }\n  )\n);\n\n/**\n * Parse the embedCode string to a DOM object for proper formatted HTML element.\n * We are only interested in the iframe element.\n */\nexport function parseIframeEmbedCode(\n  embedCode: string | undefined\n): HTMLIFrameElement | undefined {\n  try {\n    const doc = new DOMParser().parseFromString(embedCode, \"text/html\");\n    const nodeName = doc?.body?.firstChild?.nodeName;\n    // A valid embedCode should contain only the iframe element.\n    if (nodeName === \"IFRAME\") return doc.body.firstChild as HTMLIFrameElement;\n  } catch (err) {\n    console.error(err);\n  }\n  return undefined;\n}\n\nexport default AudioPlayer;\n"],"names":["thirdPartyServices","AudioPlayer","chakra","forwardRef","props","ref","audioType","className","descriptionText","embedCode","headingText","helperText","id","iframeTitle","rest","invalidEmbed","setInvalidEmbed","useState","iframeDoc","setIframeDoc","useEffect","iframe","parseIframeEmbedCode","isInvalidEmbed","isValidEmbedCode","service","errorMessage","audioType2","doc","_a","styles","useMultiStyleConfig","buildFinalElement","jsx","Box","embedElement","ComponentWrapper","Fragment","_b","err"],"mappings":"+OASA,MAAAA,EAAA,CAAA,SAAA,aAAA,SAAA,EAsCOC,EAAAC,EAAoBC,EAAA,WACzB,CAAAC,EAAAC,IAAA,CAEI,KAAA,CAAM,UAAAC,EACJ,UAAAC,EACA,gBAAAC,EACA,UAAAC,EACA,YAAAC,EACA,WAAAC,EACA,GAAAC,EACA,YAAAC,EAAA,KACc,GAAAC,CACX,EAAAV,EAGL,CAAAW,EAAAC,CAAA,EAAAC,EAAA,SAAA,EAAA,EACA,CAAAC,EAAAC,CAAA,EAAAF,EAAA,SAAkC,MAChC,EAMFG,EAAAA,UAAA,IAAA,CAEE,MAAAC,EAAAC,EAAAb,CAAA,EAGA,IAAAc,EAAA,CAAAd,GAAA,CAAAY,GAAA,CAAAG,EAAAlB,EAAAe,CAAA,EAIAA,GAAA,CAAAA,EAAA,QACEA,EAAA,MAAAR,GAAA,yBAGF,CAAA,CAAAb,EAAA,KAA0DyB,GAAAA,IAAAnB,CAC/B,GAE3B,CAAAG,IAEE,QAAA,KAAQ,wGACN,EAEFc,EAAA,IAGFP,EAAAO,CAAA,EACAJ,EAAAE,CAAA,CAAmB,EAAA,CAAAZ,EAAAH,EAAAO,CAAA,CAAA,EAGrB,MAAAa,EAAA,qHAGA,SAAAF,EAAAG,EAAAC,EAAA,OAIE,OAAAD,IAAA,UAAAE,EAAAD,GAAA,YAAAA,EAAA,MAAA,YAAAC,EAAA,SAAA,GAAAF,CAAA,QAAoE,CAGtE,MAAAG,EAAAC,EAAA,cAAA,CAAA,CAAA,EAMA,SAAAC,GAAA,CACE,OAAAd,EAAAe,EACEC,EAAC,CAAA,wBAAA,CAC0B,OAAAhB,EAAA,SACL,CACpB,CAAA,EAAA,IAEA,CAGN,MAAAiB,EAAAH,IAEA,OAAAC,EACEG,EAAC,CAAA,UAAA,eAAA7B,CAAA,GACoC,YAAAG,EACnC,gBAAAF,EACA,WAAAG,EACA,GAAA,GAAAC,CAAA,oBACS,cAAA,yBACG,IAAAP,EACZ,MAAAyB,EACO,GAAAhB,EACH,SAAAC,EAAAkB,EAGFC,EAAC,CAAA,wBAAA,CAAA,OAAAR,CAAA,EACiD,MAAAI,EAAA,OAClC,CAAA,EAAAG,EAAAI,EAAA,CAAA,SAAAF,CAAA,CAAA,CAGA,CAAA,CAEpB,CAEJ,CAEJ,EAMO,SAAAb,EAAAb,EAAA,SAGL,GAAA,CACE,MAAAmB,EAAA,IAAA,UAAA,EAAA,gBAAAnB,EAAA,WAAA,EAGA,KAFA6B,GAAAT,EAAAD,GAAA,YAAAA,EAAA,OAAA,YAAAC,EAAA,aAAA,YAAAS,EAAA,YAEA,SAA2B,OAAAV,EAAA,KAAA,UAAgB,OAAAW,EAAA,CAE3C,QAAA,MAAAA,CAAA,CAAiB,CAGrB;"}