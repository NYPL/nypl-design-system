{"version":3,"file":"Pagination-f276063d.js","sources":["../../../src/components/Pagination/Pagination.tsx"],"sourcesContent":["import { Box, chakra, useMultiStyleConfig } from \"@chakra-ui/react\";\nimport React, { forwardRef, useState, useRef } from \"react\";\n\nimport Link from \"../Link/Link\";\nimport List from \"../List/List\";\nimport { range } from \"../../utils/utils\";\n\nexport interface PaginationProps {\n  /** Additional className. */\n  className?: string;\n  /** The currentPage can be used to programatically force the selected page to change\n   * without the user explicitly requesting it – for example, if the user should be\n   * brought back to the first page of a set of results after a new search. */\n  currentPage?: number;\n  /** The callback function that takes a page number and returns a string\n   * to use for a link's `href` attribute. This is used when the current\n   * page should refresh when navigating. */\n  getPageHref?: undefined | ((pageNumber: number) => string);\n  /** ID that other components can cross reference for accessibility purposes. */\n  id?: string;\n  /** The initially selected page (default value is 1). */\n  initialPage?: number;\n  /** The callback function called when an item is selected and the current\n   * page should not refresh. */\n  onPageChange?: (selected: number) => void;\n  /** The total number of pages. */\n  pageCount: number;\n}\n\n/**\n * A component that provides a navigational list of page items.\n */\nexport const Pagination = chakra(\n  forwardRef<HTMLDivElement, PaginationProps>((props, ref?) => {\n    const {\n      className,\n      currentPage,\n      getPageHref,\n      id,\n      initialPage = 1,\n      onPageChange,\n      pageCount,\n      ...rest\n    } = props;\n    const refCurrentPage = useRef(currentPage);\n    const [selectedPage, setSelectedPage] = useState<number>(initialPage);\n    const styles = useMultiStyleConfig(\"Pagination\", {});\n    const previousPageNumber = selectedPage - 1;\n    const nextPageNumber = selectedPage + 1;\n\n    // If the parent passes down a new currentPage, and an onPageChange\n    // function exists, then set the internal state – selectedPage –\n    // to the new currentPage and update the refCurrentPage with that value.\n    React.useEffect(() => {\n      if (\n        onPageChange &&\n        currentPage &&\n        currentPage !== refCurrentPage.current\n      ) {\n        setSelectedPage(currentPage);\n        refCurrentPage.current = currentPage;\n      }\n    }, [currentPage, onPageChange]);\n\n    // If there are 0 or 1 page, the pagination should not show.\n    if (pageCount <= 1) {\n      return null;\n    }\n    if (getPageHref && onPageChange) {\n      console.warn(\n        \"NYPL Reservoir Pagination: Props for both `getPageHref` and \" +\n          \"`onPageChange` are passed. The component will default to using \" +\n          \"`getPageHref`.\"\n      );\n    }\n\n    if (getPageHref && currentPage) {\n      console.warn(\n        \"NYPL Reservoir Pagination: The `currentPage` prop does not work with \" +\n          \"the `getPageHref` prop. Use `currentPage` with `onPageChange` instead.\"\n      );\n    }\n\n    // If `getPageHref` was passed, then links should go to a new page.\n    const changeUrls =\n      typeof getPageHref !== \"undefined\" && typeof getPageHref === \"function\";\n    /**\n     * This function is only called when clicking on a link should\n     * not update the URL or refresh the page.\n     */\n    const handlePageClick = (\n      e: React.MouseEvent<HTMLDivElement | HTMLAnchorElement, MouseEvent>,\n      clickedPage: number\n    ) => {\n      e.preventDefault && e.preventDefault();\n      if (selectedPage === clickedPage) return;\n      setSelectedPage(clickedPage);\n      onPageChange && onPageChange(clickedPage);\n    };\n    // Select the previous page.\n    const previousPage = (\n      e: React.MouseEvent<HTMLDivElement | HTMLAnchorElement, MouseEvent>\n    ) => {\n      if (selectedPage > 1) {\n        handlePageClick(e, previousPageNumber);\n      }\n    };\n    // Select the next page.\n    const nextPage = (\n      e: React.MouseEvent<HTMLDivElement | HTMLAnchorElement, MouseEvent>\n    ) => {\n      if (selectedPage < pageCount) {\n        handlePageClick(e, nextPageNumber);\n      }\n    };\n    /**\n     * All `Link` components have similar attributes but we need to differentiate\n     * between the \"previous\", \"next\", and regular number links.\n     * 1. If `getPageHref` is passed, this means that the page refreshes and the\n     *    URL changes. In this case, the parent component returns the `href` URL\n     *    and the `onClick` callback is undefined.\n     * 2. Otherwise, we stay on the same page by setting the `href` attribute to\n     *    \"#\" and call the `onPageChange` prop through the `onClick` callback.\n     */\n    const getLinkElement = (\n      type: \"items\" | \"previous\" | \"next\",\n      item?: number\n    ) => {\n      const isSelectedPage = selectedPage === item;\n      // The current page link has different styles.\n      const currentStyles = isSelectedPage\n        ? {\n            color: \"ui.black\",\n            pointerEvent: \"none\",\n            _dark: {\n              color: \"dark.ui.typography.body\",\n            },\n          }\n        : {};\n      const allAttrs = {\n        items: {\n          href: changeUrls ? getPageHref(item as number) : \"#\",\n          attributes: {\n            \"aria-label\": `Page ${item}`,\n            \"aria-current\": isSelectedPage ? \"page\" : null,\n            onClick: changeUrls\n              ? undefined\n              : (\n                  e: React.MouseEvent<\n                    HTMLDivElement | HTMLAnchorElement,\n                    MouseEvent\n                  >\n                ) => handlePageClick(e, item as number),\n          },\n          text: item,\n        },\n        previous: {\n          href: changeUrls ? getPageHref(previousPageNumber) : \"#\",\n          attributes: {\n            \"aria-label\": \"Previous page\",\n            onClick: changeUrls ? undefined : previousPage,\n          },\n          text: \"Previous\",\n        },\n        next: {\n          href: changeUrls ? getPageHref(nextPageNumber) : \"#\",\n          attributes: {\n            \"aria-label\": \"Next page\",\n            onClick: changeUrls ? undefined : nextPage,\n          },\n          text: \"Next\",\n        },\n      };\n      const linkAttrs = allAttrs[type];\n      return (\n        <Link\n          href={linkAttrs.href}\n          id={`${id}-${linkAttrs.text}`}\n          {...linkAttrs.attributes}\n          __css={{\n            ...styles.link,\n            ...currentStyles,\n          }}\n        >\n          {linkAttrs.text}\n        </Link>\n      );\n    };\n\n    /**\n     * This function returns an array of `li` elements with numbers based on the\n     * total pages that `Pagination` should display. When there are many pages to\n     * display, ellipsis are shown to signify that the intermediate page numbers\n     * are hidden.\n     * For a small number of pages, the array will be simple.\n     * For a large number of pages, the resulting array will be in the shape of:\n     * [\n     *    1, this always displays\n     *    2 or an ellipsis,\n     *    a range of numbers in the middle of the total count,\n     *    pageCount - 1 or an ellipsis,\n     *    pageCount, the total number of pages\n     * ]\n     */\n    const getPaginationNumbers = (selected: number) => {\n      // Where should the middle range of numbers start at?\n      const middleRangeStart = Math.max(\n        // Start at three if the current page is near the beginning.\n        3,\n        Math.min(\n          // If the current page is in the middle, start the range\n          // one number before the current page.\n          selected - 1,\n          // If the current page is near the end, show the last five items.\n          pageCount - 4\n        )\n      );\n      // Where should the middle range of numbers end at?\n      const middleRangeEnd = Math.min(\n        // If the current page is near the end, end the range\n        // two place before the last page number.\n        pageCount - 2,\n        Math.max(\n          // If the current page is in the middle, end the range\n          // one number after the current page.\n          selected + 1,\n          // If the current page is near the end, show the first five items.\n          5\n        )\n      );\n      const itemList =\n        pageCount < 4\n          ? // Get a short array with 2 or 3 items: [1, 2] or [1, 2, 3]\n            Array.from({ length: pageCount }, (_, i) => i + 1)\n          : // Otherwise, create the longer array of items.\n            [\n              // Always display the first page.\n              1,\n              // The second item will be 2 or an ellipse.\n              middleRangeStart > 3 ? \"ellipse-start\" : 2,\n              // The middle range of page numbers to display.\n              // Add +1 to the end since range() doesn't include the last number.\n              ...range(middleRangeStart, middleRangeEnd + 1),\n              // The next to last item will be the next to last\n              // number or an ellipse.\n              middleRangeEnd < pageCount - 2 ? \"ellipse-end\" : pageCount - 1,\n              // Always display the last page.\n              pageCount,\n            ];\n      // If it's a number, render an `li` element with a link page item,\n      // otherwise return the `li` with the ellipse for a break.\n      const pageLiItems = itemList.map((item) => {\n        const itemElement =\n          typeof item === \"number\" ? getLinkElement(\"items\", item) : \"...\";\n        return <li key={item}>{itemElement}</li>;\n      });\n\n      return pageLiItems;\n    };\n\n    // Don't display the previous link when you're on the first page.\n    const previousLiLink = selectedPage !== 1 && (\n      <li key=\"previous\">{getLinkElement(\"previous\")}</li>\n    );\n    // Don't display the next link when you're on the last page.\n    const nextLiLink = selectedPage !== pageCount && (\n      <li key=\"next\">{getLinkElement(\"next\")}</li>\n    );\n\n    return (\n      <Box\n        as=\"nav\"\n        id={id}\n        aria-label=\"Pagination\"\n        role=\"navigation\"\n        className={className}\n        ref={ref}\n        __css={styles}\n        {...rest}\n      >\n        <List type=\"ul\" inline noStyling id={`${id}-list`}>\n          {previousLiLink}\n          {getPaginationNumbers(selectedPage)}\n          {nextLiLink}\n        </List>\n      </Box>\n    );\n  })\n);\n\nexport default Pagination;\n"],"names":["Pagination","chakra","forwardRef","props","ref","className","currentPage","getPageHref","id","initialPage","onPageChange","pageCount","rest","refCurrentPage","useRef","selectedPage","setSelectedPage","useState","styles","useMultiStyleConfig","previousPageNumber","nextPageNumber","React","changeUrls","handlePageClick","e","clickedPage","previousPage","nextPage","getLinkElement","type","item","isSelectedPage","currentStyles","linkAttrs","jsx","Link","getPaginationNumbers","selected","middleRangeStart","middleRangeEnd","_","i","range","itemElement","previousLiLink","nextLiLink","Box","jsxs","List"],"mappings":"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"}