import { getCategory } from "../../utils/componentCategories";
import { useState } from "react";
import {
  ArgsTable,
  Canvas,
  Description,
  Meta,
  Story,
} from "@storybook/addon-docs/blocks";
import { withDesign } from "storybook-addon-designs";

import MultiSelect from "./MultiSelect";
import useMultiSelect from "../../hooks/useMultiSelect";
import * as stories from "./MultiSelect.stories.tsx";

<Meta
  title={getCategory("MultiSelect")}
  component={MultiSelect}
  decorators={[withDesign]}
  parameters={{
    design: {
      type: "figma",
      url: "https://www.figma.com/file/qShodlfNCJHb8n03IFyApM/Main?node-id=43593%3A24611",
    },
    jest: ["MultiSelect.test.tsx"],
  }}
  argTypes={{
    label: { table: { default: "" } },
    variant: { table: { default: "listbox" }, control: false },
    items: { control: false },
    selectedItems: { control: false },
    width: { table: { default: "default" } },
    defaultIsOpen: { table: { default: false } },
    isBlockElement: { table: { default: false } },
    onApply: {
      description:
        "The action to perform for save/apply button of multiselect. `onApply: () => void;`",
    },
    onChange: {
      description:
        "The action to perform on the checkbox's onChange function. <br /> For dialog: `(event: React.ChangeEvent<HTMLInputElement>) => void` <br /> For listbox: `onChange: (selectedItem: MultiSelectItem, id: string) => void;`",
    },
    onMixedStateChange: {
      description:
        "The action to perform for a mixed state checkbox (parent checkbox). `onMixedStateChange?: (event: React.ChangeEvent<HTMLInputElement>) => void;`",
    },
  }}
/>

# MultiSelect

| Component Version | DS Version |
| ----------------- | ---------- |
| Added             | `1.1.0`    |
| Latest            | `1.1.0`    |

## Table of Contents

- [Overview](#overview)
- [Component Props](#component-props)
- [Listbox Variant](#multiselect-listbox-variant)
- [Dialog Variant](#multiselect-dialog-variant)
- [Accessibility](#accessibility)
- [Using the items prop](#using-the-items-prop)
- [Controlling state using selectedItems and onChange prop](#controlling-state-using-selecteditems-and-onchange-prop)
- [MultiSelect NextJS routing implementation](#multiselect-nextjs-routing-implementation)
- [useMultiSelect hook](#usemultiselect-hook)

## Overview

<Description of={MultiSelect} />

## Component Props

<ArgsTable story="MultiSelect ListBox" />

## MultiSelect Listbox Variant

The `MultiSelect` listbox variant renders a non-hierarchical list of items to select from.

<Canvas withToolbar>
  <Story
    name="MultiSelect ListBox"
    args={{
      id: "multiselect-listbox",
      label: "MultiSelect Listbox",
      variant: "listbox",
      width: "default",
    }}
  >
    {(args) => <stories.MultiSelectListboxStory {...args} />}
  </Story>
</Canvas>

## Accessibility

The `MultiSelect` variant `listbox` leverages `downshift.js` to assist with accessibility compliance.
By using Downshift's `useSelect` hook and prop getters `getToggleButtonProps`, `getMenuProps`, `getItemProps` we are able to create a W3 WAI-ARIA compliant listbox that behaves like a select element. Up and down arrow keys are used for navigating through the `MultiSelect` options.

The MultiSelect variant `dialog` looks similar to the Listbox variant, but because of its “clear” and “apply” buttons, it has some key functionality differences, and accessibility must be handled differently. When the multiselect is open, focus is trapped inside the dropdown menu, and the tab key is used to move through the checkboxes and buttons inside the dialog modal.

Resources:

- [downshift.js documentation](https://www.downshift-js.com/)
- [Reservoir Checkbox Component](http://localhost:6006/?path=/docs/components-form-elements-checkbox--checkbox#accessibility)
- [W3C WAI Listbox Example](https://www.w3.org/TR/2017/WD-wai-aria-practices-1.1-20170628/examples/listbox/listbox.html)
- [W3C WAI on using ARIA role=dialog](https://www.w3.org/WAI/GL/wiki/Using_ARIA_role%3Ddialog_to_implement_a_modal_dialog_box)

## MultiSelect Dialog Variant

The `MultiSelect` dialog variant allows for an optional set of child checkboxes to be passed, which makes the “parent” checkbox function as a check/uncheck all toggle.
If all of the children checkboxes are checked, the parent `isChecked` prop will be true. If only some of the child checkboxes are checked, the parent checkbox will have a `isIndeterminate` prop set to true, implying that it is not checked or unchecked.

<Canvas withToolbar>
  <Story
    name="MultiSelect Dialog"
    args={{
      id: "multiselect-dialog",
      label: "MultiSelect Dialog",
      width: "default",
      defaultIsOpen: false,
    }}
  >
    {(args) => <stories.MultiSelectDialogStory {...args} />}
  </Story>
</Canvas>

## Using the items prop

The options rendered in the MultiSelect are passed into the component's items prop.
The expected data structure is an array of objects, in the following format:

```tsx
<MultiSelect
  id="group1"
  label="Subject Specialities"
  variant="listbox"
  items={[
    {
      id: "art",
      name: "Art",
    },
    {
      id: "architecture",
      name: "Architecture",
    },
    {
      id: "art_history",
      name: "Art History",
    },
  ]}
/>
```

If choosing the `variant = 'dialog'` you can also add a second level of child items, in the following format:

```tsx
<MultiSelect
  id="group1"
  label="Subject Specialities"
  variant="dialog"
  items={[
    {
      id: "art",
      name: "Art",
    },
    {
      id: "parent_option",
      name: "Parent option",
      children: [
        {
          id: "child_1",
          name: "Child 1",
        },
        {
          id: "child_2",
          name: "Child 2",
        },
      ],
    },
  ]}
/>
```

## Controlling state using selectedItems and onChange prop

"The MultiSelect does not store its state internally. It expects a selectedItems prop whose value follows a certain data structure that is "normalized".
This is used for calculating the selected item count. The value is an object with a key of the MultiSelect's id value set to an object with an "items" key.
The "items" value is an array of the selected items. Below is an exaple of the expected state shape of `selectedItems`:

```json
{
  "subjects": {
    "items": ["art", "architecture"]
  },
  "locations": {
    "items": ["sasb"]
  }
}
```

## MultiSelect NextJS routing implementation

This is helpful for when several MultiSelect components are rendered inside a FilterBar component,
you can use the MultiSelect id to get items for a specific slice of the state.

```jsx
const subjectsSelectedItemssOnly = selectedItems["subjects"].items;
const locationsSelectedItemssOnly = selectedItems["locations"].items;
```

It's also helpful if a consuming app is pushing state into the browser's url.
This example uses NextJS's router push method to add query parameters to url.

```jsx
const multiSelectId = "subjects";
// This wouldn't be a const in real world code, but for display purposes here
// to show the state object more clearly.
const mockStateObject = {
  subjects: {
    items: ["art", "architecture"],
  },
  locations: {
    items: ["sasb"],
  },
};

// Will push ?subjects=art,architecture into browser url.
router.push({
  query: {
    [multiSelectId]: selectedItems[multiSelectId].items.join(" "),
  },
});
```

This is an example with a handleChange function to manage the `selectedItems` state, without mutating it.

```jsx
import React, { useState } from "react";
import MultiSelect from "./MultiSelect";

function MultiSelectControlledExample() {
  const [selectedItems, setSelectedItems] = useState({});

  function handleChange(multiSelectId: string, itemId: string) {
    let itemIds;
    // Check if the id already exists in the state
    if (selectedItems[multiSelectId] !== undefined) {
      let itemIdExists =
        selectedItems[multiSelectId].items.indexOf(itemId) > -1;
      // Make a copy of the existing array.
      itemIds = selectedItems[multiSelectId].items.slice();
      // If itemId exists, remove it from the array.
      if (itemIdExists) {
        itemIds = itemIds.filter((id) => id != itemId);
      } else {
        // Add it to the array, but modify the copy, not the original.
        itemIds.push(itemId);
      }
    } else {
      itemIds = [];
      itemIds.push(itemId);
    }
    setSelectedItems({
      ...selectedItems,
      [multiSelectId]: {
        items: itemIds,
      },
    });
  }

  return (
    <MultiSelect
      id="subjects"
      label="Subjects"
      items={items}
      selectedItems={selectedItems}
      onChange={(selectedItem) => {
        handleChange("id", selectedItem.id);
      }}
    />
  );
}

export default MultiSelectControlledExample;
```

## `useMultiSelect` hook

`useMultiSelect` is an optional hook provided by the component, for
cases where managing the state of the component in the consuming app is less
of a concern and general ease of use is prefered.

The hook returns an object containing all the props and state needed to handle the selectedItems.
That includes the functions `onChange`, `onClear`, `onMixedStateChange` for handling any changes to the selection of items and the current state of the selection: `selectedItems`.

<!-- Find the full documentation under [useMultiSelect](https://nypl.github.io/nypl-design-system/reservoir/v1/?path=/story/hooks-usemultiselect--page) -->
