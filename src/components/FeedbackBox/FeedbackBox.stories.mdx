import {
  ArgsTable,
  Canvas,
  Description,
  Meta,
  Story,
} from "@storybook/addon-docs";
import { useState } from "react";
import { withDesign } from "storybook-addon-designs";

import FeedbackBox from "./FeedbackBox";
import useStateWithDependencies from "../../hooks/useStateWithDependencies";
import { getCategory } from "../../utils/componentCategories";

<Meta
  title={getCategory("FeedbackBox")}
  component={FeedbackBox}
  decorators={[withDesign]}
  parameters={{
    jest: ["FeedbackBox.test.tsx"],
  }}
  argTypes={{
    className: { control: false },
    hiddenFields: { control: false },
    id: { control: false },
    isInvalidComment: { table: { defaultValue: { summary: false } } },
    isInvalidEmail: { table: { defaultValue: { summary: false } } },
    notificationText: { control: false },
    onSubmit: { control: false },
    showCategoryField: { table: { defaultValue: { summary: false } } },
    showEmailField: { table: { defaultValue: { summary: true } } },
    view: { table: { defaultValue: { summary: "form" } } },
  }}
/>

# FeedbackBox

| Component Version | DS Version |
| ----------------- | ---------- |
| Added             | `1.3.0`    |
| Latest            | `1.3.0`    |

## Table of Contents

- [Overview](#overview)
- [Component Props](#component-props)
- [Accessibility](#accessibility)
- [Notification Text](#notification-text)
- [Internal Invalid Fields](#internal-invalid-fields)
- [Form Screens](#form-screens)
- [Form Submission Data](#form-submission-data)

## Overview

<Description of={FeedbackBox} />

By default, once the form is submitted, a three (3) second timer starts. Once
the timer is complete, the "confirmation" screen is rendered. This can be
overridden by the consuming app through the `view` prop, but the value is
expected to be based on the API response of where the form data is sent.

Note: For the purposes of Storybook, the `FeedbackBox` example below alternately
renders the "confirmation" and "error" screens on each form submission. This is
just to demonstrate the different states of the component. In practice, the
consuming app is responsible for handling the form submission.

## Component Props

<Canvas withToolbar>
  <Story
    name="FeedbackBox with Controls"
    args={{
      className: undefined,
      confirmationText: "",
      descriptionText: "Please share your question or feedback.",
      hiddenFields: undefined,
      id: "feedbackBox-id",
      isInvalidComment: false,
      isInvalidEmail: false,
      notificationText: undefined,
      onSubmit: undefined,
      showCategoryField: false,
      showEmailField: false,
      title: "Help and Feedback",
      view: "form",
    }}
  >
    {(args) => {
      // This hook is used because the `view` prop can be controlled
      // by Storybook controls.
      const [internalView, setInternalView] = useStateWithDependencies(
        args.view
      );
      const [count, setCount] = useState(0);
      const hiddenFields = {
        "hidden-field-1": "hidden-field-value-1",
        "hidden-field-2": "hidden-field-value-2",
      };
      // For the purposes of the Storybook example, the confirmation and
      // error screens display on alternate form submissions.
      const onSubmit = (values) => {
        setCount((prev) => prev + 1);
        setInternalView(count % 2 === 0 ? "confirmation" : "error");
        console.log("Submitted values:", values);
      };
      return (
        <FeedbackBox
          {...args}
          hiddenFields={hiddenFields}
          notificationText={
            <span>
              <b>Call Number:</b> JFE 95-8555
            </span>
          }
          onSubmit={onSubmit}
          view={internalView}
        />
      );
    }}
  </Story>
</Canvas>

<ArgsTable story="FeedbackBox with Controls" />

## Accessibility

## Notification Text

## Internal Invalid Fields

## Form Screens

## Form Submission Data
